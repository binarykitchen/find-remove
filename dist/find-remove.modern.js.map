{"version":3,"file":"find-remove.modern.js","sources":["../src/index.js"],"sourcesContent":["const fs = require('fs')\nconst path = require('path')\nconst merge = require('fmerge')\nconst rimraf = require('rimraf')\n\nlet now\nlet testRun\n\nfunction isOlder(path, ageSeconds) {\n  const stats = fs.statSync(path)\n  const mtime = stats.mtime.getTime()\n  const expirationTime = mtime + ageSeconds * 1000\n\n  return now > expirationTime\n}\n\nfunction hasLimit(options) {\n  return options && 'limit' in options\n}\n\nfunction getLimit(options) {\n  return hasLimit(options) ? options.limit : -1\n}\n\nfunction hasTotalRemoved(options) {\n  return options && 'totalRemoved' in options\n}\n\nfunction getTotalRemoved(options) {\n  return hasTotalRemoved(options) ? options.totalRemoved : -2\n}\n\nfunction isOverTheLimit(options) {\n  return getTotalRemoved(options) >= getLimit(options)\n}\n\nfunction hasMaxLevel(options) {\n  return options && 'maxLevel' in options\n}\n\nfunction getMaxLevel(options) {\n  return hasMaxLevel(options) ? options.maxLevel : -1\n}\n\nfunction getAgeSeconds(options) {\n  return options && options.age && options.age.seconds ? options.age.seconds : null\n}\n\nfunction doDeleteDirectory(currentDir, options, currentLevel) {\n  let doDelete = false\n  const dir = options && options.dir\n\n  if (dir) {\n    const ageSeconds = getAgeSeconds(options)\n    const basename = path.basename(currentDir)\n\n    if (Array.isArray(dir)) {\n      doDelete = dir.indexOf('*') !== -1 || dir.indexOf(basename) !== -1\n    } else if (\n      (options.regex && basename.match(new RegExp(dir))) ||\n      basename === dir ||\n      dir === '*'\n    ) {\n      doDelete = true\n    }\n\n    if (doDelete && hasLimit(options)) {\n      doDelete = !isOverTheLimit(options)\n    }\n\n    if (doDelete && hasMaxLevel(options) && currentLevel > 0) {\n      doDelete = currentLevel <= getMaxLevel(options)\n    }\n\n    if (ageSeconds && doDelete) {\n      doDelete = isOlder(currentDir, ageSeconds)\n    }\n  }\n\n  return doDelete\n}\n\nfunction doDeleteFile(currentFile, options = {}) {\n  // by default it deletes nothing\n  let doDelete = false\n\n  const extensions = options.extensions ? options.extensions : null\n  const files = options.files ? options.files : null\n  const prefix = options.prefix ? options.prefix : null\n  const ignore = options && options.ignore ? options.ignore : null\n\n  // return the last portion of a path, the filename aka basename\n  const basename = path.basename(currentFile)\n\n  if (files) {\n    if (Array.isArray(files)) {\n      doDelete = files.indexOf('*.*') !== -1 || files.indexOf(basename) !== -1\n    } else {\n      if ((options.regex && basename.match(new RegExp(files))) || files === '*.*') {\n        doDelete = true\n      } else {\n        doDelete = basename === files\n      }\n    }\n  }\n\n  if (!doDelete && extensions) {\n    const currentExt = path.extname(currentFile)\n\n    if (Array.isArray(extensions)) {\n      doDelete = extensions.indexOf(currentExt) !== -1\n    } else {\n      doDelete = currentExt === extensions\n    }\n  }\n\n  if (!doDelete && prefix) {\n    doDelete = basename.indexOf(prefix) === 0\n  }\n\n  if (doDelete && hasLimit(options)) {\n    doDelete = !isOverTheLimit(options)\n  }\n\n  if (doDelete && ignore) {\n    if (Array.isArray(ignore)) {\n      doDelete = !(ignore.indexOf(basename) !== -1)\n    } else {\n      doDelete = !(basename === ignore)\n    }\n  }\n\n  if (doDelete) {\n    const ageSeconds = getAgeSeconds(options)\n\n    if (ageSeconds) {\n      doDelete = isOlder(currentFile, ageSeconds)\n    }\n  }\n\n  return doDelete\n}\n\nfunction isTestRun(options) {\n  return options && 'test' in options ? options.test : false\n}\n\n/**\n * findRemoveSync(currentDir, options) takes any start directory and searches files from there for removal.\n * the selection of files for removal depends on the given options. when no options are given, or only the maxLevel\n * parameter is given, then everything is removed as if there were no filters.\n *\n * beware: everything happens synchronously.\n *\n *\n * @param {String} currentDir any directory to operate within. it will seek files and/or directories recursively from there.\n * beware that it deletes the given currentDir when no options or only the maxLevel parameter are given.\n * @param options json object with optional properties like extensions, files, ignore, maxLevel and age.seconds.\n * @return {Object} json object of files and/or directories that were found and successfully removed.\n * @api public\n */\nconst findRemoveSync = (module.exports = function (currentDir, options, currentLevel) {\n  let removed = {}\n\n  if (!isOverTheLimit(options) && fs.existsSync(currentDir)) {\n    const maxLevel = getMaxLevel(options)\n    let deleteDirectory = false\n\n    if (hasLimit(options)) {\n      options.totalRemoved = hasTotalRemoved(options) ? getTotalRemoved(options) : 0\n    }\n\n    if (currentLevel === undefined) {\n      currentLevel = 0\n    } else {\n      currentLevel++\n    }\n\n    if (currentLevel < 1) {\n      now = new Date().getTime()\n      testRun = isTestRun(options)\n    } else {\n      // check directories before deleting files inside.\n      // this to maintain the original creation time,\n      // because linux modifies creation date of folders when files within have been deleted.\n      deleteDirectory = doDeleteDirectory(currentDir, options, currentLevel)\n    }\n\n    if (maxLevel === -1 || currentLevel < maxLevel) {\n      const filesInDir = fs.readdirSync(currentDir)\n\n      filesInDir.forEach(function (file) {\n        const currentFile = path.join(currentDir, file)\n        let skip = false\n        let stat\n\n        try {\n          stat = fs.statSync(currentFile)\n        } catch (exc) {\n          // ignore\n          skip = true\n        }\n\n        if (skip) {\n          // ignore, do nothing\n        } else if (stat.isDirectory()) {\n          // the recursive call\n          const result = findRemoveSync(currentFile, options, currentLevel)\n\n          // merge results\n          removed = merge(removed, result)\n          if (hasTotalRemoved(options)) {\n            options.totalRemoved += Object.keys(result).length\n          }\n        } else {\n          if (doDeleteFile(currentFile, options)) {\n            let unlinked\n\n            if (!testRun) {\n              try {\n                fs.unlinkSync(currentFile)\n                unlinked = true\n              } catch (exc) {\n                // ignore\n              }\n            } else {\n              unlinked = true\n            }\n\n            if (unlinked) {\n              removed[currentFile] = true\n              if (hasTotalRemoved(options)) {\n                options.totalRemoved++\n              }\n            }\n          }\n        }\n      })\n    }\n\n    if (deleteDirectory) {\n      if (!testRun) {\n        rimraf.sync(currentDir)\n      }\n\n      if (!hasTotalRemoved(options)) {\n        // for limit of files - we do not want to count the directories\n        removed[currentDir] = true\n      }\n    }\n  }\n\n  return removed\n})\n"],"names":["fs","require","path","merge","rimraf","now","testRun","isOlder","ageSeconds","mtime","statSync","getTime","hasLimit","options","hasTotalRemoved","getTotalRemoved","totalRemoved","isOverTheLimit","limit","getLimit","hasMaxLevel","getMaxLevel","maxLevel","getAgeSeconds","age","seconds","findRemoveSync","module","exports","currentDir","currentLevel","removed","existsSync","deleteDirectory","undefined","Date","test","isTestRun","doDelete","dir","basename","Array","isArray","indexOf","regex","match","RegExp","doDeleteDirectory","readdirSync","forEach","file","currentFile","join","stat","skip","exc","isDirectory","result","Object","keys","length","extensions","files","prefix","ignore","currentExt","extname","doDeleteFile","unlinked","unlinkSync","sync"],"mappings":"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"}