{"version":3,"file":"find-remove.umd.js","sources":["../src/index.ts"],"sourcesContent":["import fs from \"fs\";\nimport path from \"path\";\nimport { rimrafSync } from \"rimraf\";\n\nlet now: number | undefined;\nlet testRun: boolean | undefined;\n\ninterface Options {\n  test?: boolean;\n  limit?: number;\n  totalRemoved?: number;\n  maxLevel?: number;\n  dir?: string | string[];\n  regex?: boolean;\n  prefix?: string;\n  ignore?: string | string[];\n  extensions?: string | string[];\n  files?: string | string[];\n  age?: {\n    seconds?: number;\n  };\n}\n\nfunction isOlder(path: string, ageSeconds: number) {\n  if (!now) return false;\n  const stats = fs.statSync(path);\n  const mtime = stats.mtime.getTime();\n  const expirationTime = mtime + ageSeconds * 1000;\n\n  return now > expirationTime;\n}\n\nfunction getLimit(options: Options = {}) {\n  if (options.limit !== undefined) {\n    return options.limit;\n  }\n\n  return -1;\n}\n\nfunction getTotalRemoved(options: Options = {}) {\n  if (options.totalRemoved !== undefined) {\n    return options.totalRemoved;\n  }\n\n  return -2;\n}\n\nfunction isOverTheLimit(options: Options = {}) {\n  return getTotalRemoved(options) >= getLimit(options);\n}\n\nfunction getMaxLevel(options: Options = {}) {\n  if (options.maxLevel !== undefined) {\n    return options.maxLevel;\n  }\n\n  return -1;\n}\n\nfunction getAgeSeconds(options: Options = {}) {\n  return options.age && options.age.seconds ? options.age.seconds : null;\n}\n\nfunction doDeleteDirectory(\n  currentDir: string,\n  options: Options = {},\n  currentLevel: number,\n) {\n  let doDelete = false;\n\n  const dir = options.dir;\n\n  if (dir) {\n    const ageSeconds = getAgeSeconds(options);\n    const basename = path.basename(currentDir);\n\n    if (Array.isArray(dir)) {\n      doDelete = dir.indexOf(\"*\") !== -1 || dir.indexOf(basename) !== -1;\n    } else if (\n      (options.regex && basename.match(new RegExp(dir))) ||\n      basename === dir ||\n      dir === \"*\"\n    ) {\n      doDelete = true;\n    }\n\n    if (doDelete && options.limit !== undefined) {\n      doDelete = !isOverTheLimit(options);\n    }\n\n    if (doDelete && options.maxLevel !== undefined && currentLevel > 0) {\n      doDelete = currentLevel <= getMaxLevel(options);\n    }\n\n    if (ageSeconds && doDelete) {\n      doDelete = isOlder(currentDir, ageSeconds);\n    }\n  }\n\n  return doDelete;\n}\n\nfunction doDeleteFile(currentFile: string, options: Options = {}) {\n  // by default it deletes nothing\n  let doDelete = false;\n\n  const extensions = options.extensions ? options.extensions : null;\n  const files = options.files ? options.files : null;\n  const prefix = options.prefix ? options.prefix : null;\n  const ignore = options && options.ignore ? options.ignore : null;\n\n  // return the last portion of a path, the filename aka basename\n  const basename = path.basename(currentFile);\n\n  if (files) {\n    if (Array.isArray(files)) {\n      doDelete = files.indexOf(\"*.*\") !== -1 || files.indexOf(basename) !== -1;\n    } else {\n      if ((options.regex && basename.match(new RegExp(files))) || files === \"*.*\") {\n        doDelete = true;\n      } else {\n        doDelete = basename === files;\n      }\n    }\n  }\n\n  if (!doDelete && extensions) {\n    const currentExt = path.extname(currentFile);\n\n    if (Array.isArray(extensions)) {\n      doDelete = extensions.indexOf(currentExt) !== -1;\n    } else {\n      doDelete = currentExt === extensions;\n    }\n  }\n\n  if (!doDelete && prefix) {\n    doDelete = basename.indexOf(prefix) === 0;\n  }\n\n  if (doDelete && options.limit !== undefined) {\n    doDelete = !isOverTheLimit(options);\n  }\n\n  if (doDelete && ignore) {\n    if (Array.isArray(ignore)) {\n      doDelete = !(ignore.indexOf(basename) !== -1);\n    } else {\n      doDelete = !(basename === ignore);\n    }\n  }\n\n  if (doDelete) {\n    const ageSeconds = getAgeSeconds(options);\n\n    if (ageSeconds) {\n      doDelete = isOlder(currentFile, ageSeconds);\n    }\n  }\n\n  return doDelete;\n}\n\n/**\n * FindRemoveSync(currentDir, options) takes any start directory and searches files from there for removal.\n * the selection of files for removal depends on the given options. when no options are given, or only the maxLevel\n * parameter is given, then everything is removed as if there were no filters.\n *\n * Beware: everything happens synchronously.\n *\n *\n * @param {string} currentDir any directory to operate within. it will seek files and/or directories recursively from there.\n * beware that it deletes the given currentDir when no options or only the maxLevel parameter are given.\n * @param options json object with optional properties like extensions, files, ignore, maxLevel and age.seconds.\n * @return {Object} json object of files and/or directories that were found and successfully removed.\n * @api public\n */\nconst findRemoveSync = function (\n  currentDir: string,\n  options: Options = {},\n  currentLevel?: number,\n) {\n  let removed: Record<string, boolean> = {};\n\n  if (!isOverTheLimit(options) && fs.existsSync(currentDir)) {\n    const maxLevel = getMaxLevel(options);\n    let deleteDirectory = false;\n\n    if (options.limit !== undefined) {\n      options.totalRemoved =\n        options.totalRemoved !== undefined ? getTotalRemoved(options) : 0;\n    }\n\n    if (currentLevel === undefined) {\n      currentLevel = 0;\n    } else {\n      currentLevel++;\n    }\n\n    if (currentLevel < 1) {\n      now = new Date().getTime();\n      testRun = options.test;\n    } else {\n      // check directories before deleting files inside.\n      // this to maintain the original creation time,\n      // because linux modifies creation date of folders when files within have been deleted.\n      deleteDirectory = doDeleteDirectory(currentDir, options, currentLevel);\n    }\n\n    if (maxLevel === -1 || currentLevel < maxLevel) {\n      const filesInDir = fs.readdirSync(currentDir);\n\n      filesInDir.forEach(function (file) {\n        const currentFile = path.join(currentDir, file);\n        let skip = false;\n        let stat;\n\n        try {\n          stat = fs.statSync(currentFile);\n        } catch (exc) {\n          // ignore\n          skip = true;\n        }\n\n        if (skip) {\n          // ignore, do nothing\n        } else if (stat?.isDirectory()) {\n          // the recursive call\n          const result = findRemoveSync(currentFile, options, currentLevel);\n\n          // merge results\n          removed = Object.assign({}, removed, result);\n\n          if (options.totalRemoved !== undefined) {\n            options.totalRemoved += Object.keys(result).length;\n          }\n        } else {\n          if (doDeleteFile(currentFile, options)) {\n            let unlinked;\n\n            if (!testRun) {\n              try {\n                fs.unlinkSync(currentFile);\n                unlinked = true;\n              } catch (exc) {\n                // ignore\n              }\n            } else {\n              unlinked = true;\n            }\n\n            if (unlinked) {\n              removed[currentFile] = true;\n\n              if (options.totalRemoved !== undefined) {\n                options.totalRemoved++;\n              }\n            }\n          }\n        }\n      });\n    }\n\n    if (deleteDirectory) {\n      if (!testRun) {\n        rimrafSync(currentDir);\n      }\n\n      if (options.totalRemoved === undefined) {\n        // for limit of files - we do not want to count the directories\n        removed[currentDir] = true;\n      }\n    }\n  }\n\n  return removed;\n};\n\nexport default findRemoveSync;\n"],"names":["now","testRun","isOlder","path","ageSeconds","mtime","fs","statSync","getTime","getTotalRemoved","options","undefined","totalRemoved","isOverTheLimit","limit","getLimit","getMaxLevel","maxLevel","getAgeSeconds","age","seconds","findRemoveSync","currentDir","currentLevel","removed","existsSync","deleteDirectory","Date","test","doDelete","dir","basename","Array","isArray","indexOf","regex","match","RegExp","doDeleteDirectory","readdirSync","forEach","file","_stat","stat","currentFile","join","skip","exc","isDirectory","result","Object","assign","keys","length","extensions","files","prefix","ignore","currentExt","extname","doDeleteFile","unlinked","unlinkSync","rimrafSync"],"mappings":"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"}