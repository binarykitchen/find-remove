{"version":3,"file":"find-remove.umd.js","sources":["../src/index.js"],"sourcesContent":["const fs = require('fs')\nconst path = require('path')\nconst merge = require('fmerge')\nconst rimraf = require('rimraf')\n\nlet now\nlet testRun\n\nfunction isOlder(path, ageSeconds) {\n  const stats = fs.statSync(path)\n  const mtime = stats.mtime.getTime()\n  const expirationTime = mtime + ageSeconds * 1000\n\n  return now > expirationTime\n}\n\nfunction hasLimit(options) {\n  return options && 'limit' in options\n}\n\nfunction getLimit(options) {\n  return hasLimit(options) ? options.limit : -1\n}\n\nfunction hasTotalRemoved(options) {\n  return options && 'totalRemoved' in options\n}\n\nfunction getTotalRemoved(options) {\n  return hasTotalRemoved(options) ? options.totalRemoved : -2\n}\n\nfunction isOverTheLimit(options) {\n  return getTotalRemoved(options) >= getLimit(options)\n}\n\nfunction hasMaxLevel(options) {\n  return options && 'maxLevel' in options\n}\n\nfunction getMaxLevel(options) {\n  return hasMaxLevel(options) ? options.maxLevel : -1\n}\n\nfunction getAgeSeconds(options) {\n  return options && options.age && options.age.seconds ? options.age.seconds : null\n}\n\nfunction doDeleteDirectory(currentDir, options, currentLevel) {\n  let doDelete = false\n  const dir = options && options.dir\n\n  if (dir) {\n    const ageSeconds = getAgeSeconds(options)\n    const basename = path.basename(currentDir)\n\n    if (Array.isArray(dir)) {\n      doDelete = dir.indexOf('*') !== -1 || dir.indexOf(basename) !== -1\n    } else if (basename === dir || dir === '*') {\n      doDelete = true\n    }\n\n    if (doDelete && hasLimit(options)) {\n      doDelete = !isOverTheLimit(options)\n    }\n\n    if (doDelete && hasMaxLevel(options) && currentLevel > 0) {\n      doDelete = currentLevel <= getMaxLevel(options)\n    }\n\n    if (ageSeconds && doDelete) {\n      doDelete = isOlder(currentDir, ageSeconds)\n    }\n  }\n\n  return doDelete\n}\n\nfunction doDeleteFile(currentFile, options = {}) {\n  // by default it deletes nothing\n  let doDelete = false\n\n  const extensions = options.extensions ? options.extensions : null\n  const files = options.files ? options.files : null\n  const prefix = options.prefix ? options.prefix : null\n  const ignore = options && options.ignore ? options.ignore : null\n\n  // return the last portion of a path, the filename aka basename\n  const basename = path.basename(currentFile)\n\n  if (files) {\n    if (Array.isArray(files)) {\n      doDelete = files.indexOf('*.*') !== -1 || files.indexOf(basename) !== -1\n    } else {\n      if (files === '*.*') {\n        doDelete = true\n      } else {\n        doDelete = basename === files\n      }\n    }\n  }\n\n  if (!doDelete && extensions) {\n    const currentExt = path.extname(currentFile)\n\n    if (Array.isArray(extensions)) {\n      doDelete = extensions.indexOf(currentExt) !== -1\n    } else {\n      doDelete = currentExt === extensions\n    }\n  }\n\n  if (!doDelete && prefix) {\n    doDelete = basename.indexOf(prefix) === 0\n  }\n\n  if (doDelete && hasLimit(options)) {\n    doDelete = !isOverTheLimit(options)\n  }\n\n  if (doDelete && ignore) {\n    if (Array.isArray(ignore)) {\n      doDelete = !(ignore.indexOf(basename) !== -1)\n    } else {\n      doDelete = !(basename === ignore)\n    }\n  }\n\n  if (doDelete) {\n    const ageSeconds = getAgeSeconds(options)\n\n    if (ageSeconds) {\n      doDelete = isOlder(currentFile, ageSeconds)\n    }\n  }\n\n  return doDelete\n}\n\nfunction isTestRun(options) {\n  return options && 'test' in options ? options.test : false\n}\n\n/**\n * findRemoveSync(currentDir, options) takes any start directory and searches files from there for removal.\n * the selection of files for removal depends on the given options. when no options are given, or only the maxLevel\n * parameter is given, then everything is removed as if there were no filters.\n *\n * beware: everything happens synchronously.\n *\n *\n * @param {String} currentDir any directory to operate within. it will seek files and/or directories recursively from there.\n * beware that it deletes the given currentDir when no options or only the maxLevel parameter are given.\n * @param options json object with optional properties like extensions, files, ignore, maxLevel and age.seconds.\n * @return {Object} json object of files and/or directories that were found and successfully removed.\n * @api public\n */\nconst findRemoveSync = (module.exports = function (currentDir, options, currentLevel) {\n  let removed = {}\n\n  if (!isOverTheLimit(options) && fs.existsSync(currentDir)) {\n    const maxLevel = getMaxLevel(options)\n    let deleteDirectory = false\n\n    if (hasLimit(options)) {\n      options.totalRemoved = hasTotalRemoved(options) ? getTotalRemoved(options) : 0\n    }\n\n    if (currentLevel === undefined) {\n      currentLevel = 0\n    } else {\n      currentLevel++\n    }\n\n    if (currentLevel < 1) {\n      now = new Date().getTime()\n      testRun = isTestRun(options)\n    } else {\n      // check directories before deleting files inside.\n      // this to maintain the original creation time,\n      // because linux modifies creation date of folders when files within have been deleted.\n      deleteDirectory = doDeleteDirectory(currentDir, options, currentLevel)\n    }\n\n    if (maxLevel === -1 || currentLevel < maxLevel) {\n      const filesInDir = fs.readdirSync(currentDir)\n\n      filesInDir.forEach(function (file) {\n        const currentFile = path.join(currentDir, file)\n        let skip = false\n        let stat\n\n        try {\n          stat = fs.statSync(currentFile)\n        } catch (exc) {\n          // ignore\n          skip = true\n        }\n\n        if (skip) {\n          // ignore, do nothing\n        } else if (stat.isDirectory()) {\n          // the recursive call\n          const result = findRemoveSync(currentFile, options, currentLevel)\n\n          // merge results\n          removed = merge(removed, result)\n          if (hasTotalRemoved(options)) {\n            options.totalRemoved += Object.keys(result).length\n          }\n        } else {\n          if (doDeleteFile(currentFile, options)) {\n            let unlinked\n\n            if (!testRun) {\n              try {\n                fs.unlinkSync(currentFile)\n                unlinked = true\n              } catch (exc) {\n                // ignore\n              }\n            } else {\n              unlinked = true\n            }\n\n            if (unlinked) {\n              removed[currentFile] = true\n              if (hasTotalRemoved(options)) {\n                options.totalRemoved++\n              }\n            }\n          }\n        }\n      })\n    }\n\n    if (deleteDirectory) {\n      if (!testRun) {\n        rimraf.sync(currentDir)\n      }\n\n      if (!hasTotalRemoved(options)) {\n        // for limit of files - we do not want to count the directories\n        removed[currentDir] = true\n      }\n    }\n  }\n\n  return removed\n})\n"],"names":["now","testRun","fs","require","path","merge","rimraf","isOlder","ageSeconds","mtime","statSync","getTime","hasLimit","options","hasTotalRemoved","getTotalRemoved","totalRemoved","isOverTheLimit","limit","getLimit","hasMaxLevel","getMaxLevel","maxLevel","getAgeSeconds","age","seconds","findRemoveSync","module","exports","currentDir","currentLevel","removed","existsSync","deleteDirectory","undefined","Date","test","isTestRun","doDelete","dir","basename","Array","isArray","indexOf","doDeleteDirectory","readdirSync","forEach","file","stat","currentFile","join","skip","exc","isDirectory","result","Object","keys","length","extensions","files","prefix","ignore","currentExt","extname","doDeleteFile","unlinked","unlinkSync","sync"],"mappings":"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"}