{"version":3,"file":"find-remove.js","sources":["../src/index.js"],"sourcesContent":["const fs = require('fs')\nconst path = require('path')\nconst merge = require('fmerge')\nconst rimraf = require('rimraf')\n\nlet now\nlet testRun\n\nfunction isOlder(path, ageSeconds) {\n  const stats = fs.statSync(path)\n  const mtime = stats.mtime.getTime()\n  const expirationTime = mtime + ageSeconds * 1000\n\n  return now > expirationTime\n}\n\nfunction hasLimit(options) {\n  return options && 'limit' in options\n}\n\nfunction getLimit(options) {\n  return hasLimit(options) ? options.limit : -1\n}\n\nfunction hasTotalRemoved(options) {\n  return options && 'totalRemoved' in options\n}\n\nfunction getTotalRemoved(options) {\n  return hasTotalRemoved(options) ? options.totalRemoved : -2\n}\n\nfunction isOverTheLimit(options) {\n  return getTotalRemoved(options) >= getLimit(options)\n}\n\nfunction hasMaxLevel(options) {\n  return options && 'maxLevel' in options\n}\n\nfunction getMaxLevel(options) {\n  return hasMaxLevel(options) ? options.maxLevel : -1\n}\n\nfunction getAgeSeconds(options) {\n  return options && options.age && options.age.seconds ? options.age.seconds : null\n}\n\nfunction doDeleteDirectory(currentDir, options, currentLevel) {\n  let doDelete = false\n  const dir = options && options.dir\n\n  if (dir) {\n    const ageSeconds = getAgeSeconds(options)\n    const basename = path.basename(currentDir)\n\n    if (Array.isArray(dir)) {\n      doDelete = dir.indexOf('*') !== -1 || dir.indexOf(basename) !== -1\n    } else if (\n      (options.regex && basename.match(new RegExp(dir))) ||\n      basename === dir ||\n      dir === '*'\n    ) {\n      doDelete = true\n    }\n\n    if (doDelete && hasLimit(options)) {\n      doDelete = !isOverTheLimit(options)\n    }\n\n    if (doDelete && hasMaxLevel(options) && currentLevel > 0) {\n      doDelete = currentLevel <= getMaxLevel(options)\n    }\n\n    if (ageSeconds && doDelete) {\n      doDelete = isOlder(currentDir, ageSeconds)\n    }\n  }\n\n  return doDelete\n}\n\nfunction doDeleteFile(currentFile, options = {}) {\n  // by default it deletes nothing\n  let doDelete = false\n\n  const extensions = options.extensions ? options.extensions : null\n  const files = options.files ? options.files : null\n  const prefix = options.prefix ? options.prefix : null\n  const ignore = options && options.ignore ? options.ignore : null\n\n  // return the last portion of a path, the filename aka basename\n  const basename = path.basename(currentFile)\n\n  if (files) {\n    if (Array.isArray(files)) {\n      doDelete = files.indexOf('*.*') !== -1 || files.indexOf(basename) !== -1\n    } else {\n      if ((options.regex && basename.match(new RegExp(files))) || files === '*.*') {\n        doDelete = true\n      } else {\n        doDelete = basename === files\n      }\n    }\n  }\n\n  if (!doDelete && extensions) {\n    const currentExt = path.extname(currentFile)\n\n    if (Array.isArray(extensions)) {\n      doDelete = extensions.indexOf(currentExt) !== -1\n    } else {\n      doDelete = currentExt === extensions\n    }\n  }\n\n  if (!doDelete && prefix) {\n    doDelete = basename.indexOf(prefix) === 0\n  }\n\n  if (doDelete && hasLimit(options)) {\n    doDelete = !isOverTheLimit(options)\n  }\n\n  if (doDelete && ignore) {\n    if (Array.isArray(ignore)) {\n      doDelete = !(ignore.indexOf(basename) !== -1)\n    } else {\n      doDelete = !(basename === ignore)\n    }\n  }\n\n  if (doDelete) {\n    const ageSeconds = getAgeSeconds(options)\n\n    if (ageSeconds) {\n      doDelete = isOlder(currentFile, ageSeconds)\n    }\n  }\n\n  return doDelete\n}\n\nfunction isTestRun(options) {\n  return options && 'test' in options ? options.test : false\n}\n\n/**\n * findRemoveSync(currentDir, options) takes any start directory and searches files from there for removal.\n * the selection of files for removal depends on the given options. when no options are given, or only the maxLevel\n * parameter is given, then everything is removed as if there were no filters.\n *\n * beware: everything happens synchronously.\n *\n *\n * @param {String} currentDir any directory to operate within. it will seek files and/or directories recursively from there.\n * beware that it deletes the given currentDir when no options or only the maxLevel parameter are given.\n * @param options json object with optional properties like extensions, files, ignore, maxLevel and age.seconds.\n * @return {Object} json object of files and/or directories that were found and successfully removed.\n * @api public\n */\nconst findRemoveSync = (module.exports = function (currentDir, options, currentLevel) {\n  let removed = {}\n\n  if (!isOverTheLimit(options) && fs.existsSync(currentDir)) {\n    const maxLevel = getMaxLevel(options)\n    let deleteDirectory = false\n\n    if (hasLimit(options)) {\n      options.totalRemoved = hasTotalRemoved(options) ? getTotalRemoved(options) : 0\n    }\n\n    if (currentLevel === undefined) {\n      currentLevel = 0\n    } else {\n      currentLevel++\n    }\n\n    if (currentLevel < 1) {\n      now = new Date().getTime()\n      testRun = isTestRun(options)\n    } else {\n      // check directories before deleting files inside.\n      // this to maintain the original creation time,\n      // because linux modifies creation date of folders when files within have been deleted.\n      deleteDirectory = doDeleteDirectory(currentDir, options, currentLevel)\n    }\n\n    if (maxLevel === -1 || currentLevel < maxLevel) {\n      const filesInDir = fs.readdirSync(currentDir)\n\n      filesInDir.forEach(function (file) {\n        const currentFile = path.join(currentDir, file)\n        let skip = false\n        let stat\n\n        try {\n          stat = fs.statSync(currentFile)\n        } catch (exc) {\n          // ignore\n          skip = true\n        }\n\n        if (skip) {\n          // ignore, do nothing\n        } else if (stat.isDirectory()) {\n          // the recursive call\n          const result = findRemoveSync(currentFile, options, currentLevel)\n\n          // merge results\n          removed = merge(removed, result)\n          if (hasTotalRemoved(options)) {\n            options.totalRemoved += Object.keys(result).length\n          }\n        } else {\n          if (doDeleteFile(currentFile, options)) {\n            let unlinked\n\n            if (!testRun) {\n              try {\n                fs.unlinkSync(currentFile)\n                unlinked = true\n              } catch (exc) {\n                // ignore\n              }\n            } else {\n              unlinked = true\n            }\n\n            if (unlinked) {\n              removed[currentFile] = true\n              if (hasTotalRemoved(options)) {\n                options.totalRemoved++\n              }\n            }\n          }\n        }\n      })\n    }\n\n    if (deleteDirectory) {\n      if (!testRun) {\n        rimraf.sync(currentDir)\n      }\n\n      if (!hasTotalRemoved(options)) {\n        // for limit of files - we do not want to count the directories\n        removed[currentDir] = true\n      }\n    }\n  }\n\n  return removed\n})\n"],"names":["require","path","ageSeconds","fs","statSync","mtime","getTime","options","totalRemoved","limit","getLimit","maxLevel","age","seconds","module","exports","currentDir","currentLevel","isOverTheLimit","existsSync","getMaxLevel","hasLimit","hasTotalRemoved","getTotalRemoved","undefined","now","testRun","test","isTestRun","deleteDirectory","dir","getAgeSeconds","basename","Array","isArray","doDelete","indexOf","regex","match","hasMaxLevel","isOlder","doDeleteDirectory","readdirSync","forEach","file","join","stat","currentFile","exc","skip","isDirectory","findRemoveSync","removed","merge","result","Object","keys","length","extensions","files","prefix","ignore","extname","currentExt","doDeleteFile","unlinked","unlinkSync","rimraf","sync"],"mappings":"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"}